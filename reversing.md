# Reverse Engineering Notes

**This is just a page of notes and important things to me to remember while learning Reverse Engineering**

### Threads, Functions and Stacks

- **Each thread executing inside a process has its own stack. // 5 Threads = 5 Stacks**

- **When a function is called, it places its parameters on the stack, PUSH places data on top of the stack and POP removes that value from the top of the stack. LIFO (Last In - First Out).**

- **When an item is pushed onto the stack, the ESP register, which always points to the Top of the Stack, is decremented in order to point to the new item placed on the Top. Works the same the other way around, POPing from the stack will increment in order to point to the item below. EBP just points to the bottom becauSE IT IS A BASE POINTER.**

- **CALL is obviously responsible for executing functions, it loads the entry point of the function into the EIP register in order to run it. RET for exiting functions**

- **The program in execution needs to "remember" the return address each time the execution flow enters a function and that function needs to have its own memory area where it can store return addresses, local variables, etc. This is done by splitting the memory assigned for the stack into stack frames, each frame holds the information just mentioned for each function.**

### Heaps, Handles, and Exceptions.

- **Heaps are memory areas dynamically allocated at runtime, used to store data that doesn't have a fixed size or data that can't fit inside the stack.**

- **Handles can be considered references to various resources, and they are used by the OS in order to control the resources access (read, write, etc.)**

- **Exceptions are a specific type of event that occurs during the execution of an applications. They are usually associated with specific exception handlers, which are code blocks dedicated to handle that type of event correctly. Exceptions can also be caused by programming errors, so it is important to have an exception handler that will prevent the application from crashing unexpectedly. You also have Hardware and Software exceptions**

- **Hardware exceptions are usually caused by the execution of a bad sequence of instructions such as division by zero or an attempt to access an invalid memory location. On the other hand Software exceptions are generated by the application or the OS itself, and can be used in order to flag certain conditions with user defined exception codes.**

- **Windows implements its own mechanism to handle exceptions which is called Structured Exception Handling, or SEH for short**

- **Tricks like redirecting the execution flow to inside the handler and then back to the normal execution flow can be commonly used as an anti-reversing trick.**

### Basic Windows Ring3 Internal Structures.

- **```THREAD_ENVIRONMENT_BLOCK (TEB)```. This structure stores information such as the addresses of the top and bottom of the current thread's stack, the thread identifier, the identifier of the process the thread belongs to, the code of the last error that occurred during the thread execution, the address of the ```Thread Local Storage (TLS)```, and the address of the ```PROCESS_ENVIRONMENT_BLOCK (PEB)```**

- **```PROCESS_ENVIRONMENT_BLOCK (PEB)```. The PEB structure is also very important to understand. Some of the information stored in the PEB is: the image base of the process, the address of the loader data structure (```PEB_LDR_DATA``` - which contains pointers to lists regarding the modules loaded by the process). The ```NtGlobalFlag``` value, the major and minor versions of the Windows OS, the number of processors available, the ```BeingDebugged``` flag, and much more**

- **Some of the information stored inside PEB can be used for debugger detection, such as the ```NtGlobalFlag``` or ```BeingDebugged```.**

- **Another important structure is the ```CONTEXT``` structure, the system uses this structure to keep track of all necessary CPU state information afor a specific thread under execution during internal operations. For example, it stored the values of the registers which would be necessary to continue in the execution of the thread from the correct virtual address in case an event (like an exception) occurs.**

### Windows APIs

- **Windows APIs are Ring3 operating system functions. Their use is well documented, the parameters they receive and their purpose clear so that they can be used by the programmers in order to take advantage of the various functionalities of the operating system.**

- **Basically communication tunnel between running application and kernel**

### Types of Reversing Tools

- **Hex Editor like HxD**

- **Decompiler like DnSpy for .NET, Ghidra for native**

- **Disassembler like IDA Pro or Ghidra again**

- **Debugger like x64dbg or gdb-gef**

- **System monitoring tools like Process Hacker or Procmon**

- **Windows API monitoring tools**

### VA/RVA/Offset

- **Applications do not directly access physical memory, only virtual memory. Memory addresses referenced by an application are virtual addresses (VAs).**

- **A relative virtual address (RVA) is the difference between two VAs and refers to the highest one.**

### How to calculate offsets:
```
VA_1 = 0x00400000
VA_2 = 0x00401000
RVA of VA_2 = VA_2 - VA_1 = 0x00001000
```

- **On the other hand, offsets are usually refered to as either physical memory, a physical file on the disk, or in other general cases where we treat data as raw data, without worrying about any differences in the internal alignment of this data on memory against the one on the disk.**

- **The offset is the difference between the locations of 2 bytes, for example inside a file, usually starting from the beginning of the file. You can find this in tools like Ghidra which show the offset of certain functions and instructions.**

- **If we want to bypass a anti-reversing function or trick, we can use information like offsets of the bytes you want to modify on the disk and patching code in memory as a testing solution.**

- **Opcodes are important btw, for example ```JNZ```'s opcode would be 0x75.**

### Patching Lab #1

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/ca14c83d-ffb7-46a9-a106-83261034816b)

Here we have a regular program that is looking for a valid input, we can see at address ```0x402E76``` there is a ```JNZ``` (jump if not zero) instruction where a decision is taken regarding an output.

Above that we can see ```TEST EAX,EAX``` which checks the value of ```EAX``` to see if it is zero or not, if it is NOT then the conditional jump that follows will redirect the execution to the "invalid" message. Otherwise the execution will continue with the good message.

To bypass this, we can change the ```JNZ``` instruction to ```JZ``` using the "Assemble" command 

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/cf696601-2de8-4476-800d-e2dd790829b7)

After we edit this and run the program, we can input any key and it becomes valid

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/d2f7cbf3-f8b7-4950-a037-586dea0c7fa9)

We can also do the same thing by changing the address of the jump condition to jump to the "valid" memory address ```(0x402E78)``` instead of the invalid one ```(0x402E97```

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/1dda65f7-109e-409c-9803-1f961544817b)

### Finding Byte Offset

I want to patch the byte located at VA ```0x00402E77```

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/dfb796cf-5260-490f-a400-32003a38b912)

Use ALT+M to get to the memory map and find the first section which is at ```0x00401000```

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/d050869f-9ba3-4d80-8e18-d2ac9221dbde)

Right click the PE Header ```(0x00400000)``` and click Dump in CPU

The bottom part of the interface will now be filled with human-readable information

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/31e9ed7d-7fad-4f60-bce0-40df002af553)

Scroll down a bit more and you'll find the first section of the PE Header, the .text section.

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/cbc98583-68e4-4d66-98e1-cbe562e340aa)

The comments squared in red are the ones we will need to find the byte offset

- **VirtualSize:** The size of the section in memory.
- **VirtualAddress:** The RVA of the section in memory, not the VA.
- **SizeOfRawData:** Size of the section in the file.
- **PointerToRawData:** Starting offset of the section in the file.

The below is the formula to calculate the information

```Byte_Offset = Byte_VA - (Image_Base + Section_RVA) + PointerToRawData```

So it would be:

```0x00402E77 - (0x400000 + 0x1000) + 0x600 = 0x2477```

Putting the binary in **HxD** and scrolling down to ```0x2477`` brings us to the same hex values we saw in Ollydbg!

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/73e3f828-7b69-4352-ad94-3a64fa81c763)

And at the bottom left we can see the offset is ```0x2477```

Changing the Hex values to ```75 00``` and saving the file means we have fully patched the binary!

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/60598fe0-b265-4877-8978-c0917f3db0d7)

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/76cbd9ac-0372-4a02-8f6c-ea8dd06db4cd)

And we win!

### Exploring the Stack with Lab #2

Because strings this time are XOR encrypted and we can't just search for string references, we must use the stack while the program is running to see data being passed through it when it has been decrypted.

Using F12 or the Pause icon at the top toolbar of Ollydbg, means we can pause execution of the program and analyse the stack at runtime. After triggering a "This code is invalid!!!" I searched through the stack for this string, once i found it, i ensured this was the correct string since there were many different "This code is invalid!!!" strings on the stack, i confirmed this was my target by seeing the ```CALL``` that is made to the ```MessageBoxW``` WinAPI function.

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/50bcf678-d9d9-4ef7-afd2-f828a4464f38)

Right click on the function in the stack you want to go to in CPU, and click "Follow in Disassembler". I can also use CTRL+G to go straight to the memory address location of the function in CPU.

- **NOTE: Some Windows API names have an appended "A" or "W" in the end in order to indicate their ANSI or Unicode name respectively. For example, in case ```MessageBoxA``` call is used when we need to use ASCII character strings, otherwise, we use ```MessageBoxW``` for Unicode character strings.**

Scrolling up a bit further we can see some JMP conditional calls and more MessageBox's. This is probably where most of the decision making is happening:

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/90138792-9778-4afe-8262-6a1fa09cd125)

I can set a breakpoint just before the comparison is made to check if the right string has been inputted:

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/eb18231c-d90a-44b9-acb2-52ba39524d32)

After running the program with F9 we should hit the breakpoint and have some information in the stack:

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/3c9be26f-a5ca-4894-ab2d-5f5de353483d)

As you can see, since the code to decrypt the string has been ran, we can see the correct password for the program in the stack clearly!

```0019F4EC   0063B26C  UNICODE "Fr0m-sma11-b3g1nn1ng5-c0m3-grea7-th1ng5"```

Using this code we can check and see that we get the win

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/d14aa4f1-f2d7-4da1-a2fb-e4d270452da1)

I also used HxD to permanently patch this program, I used the Byte Offset calculation formula to get the location of the hex values that needed to be edited

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/f500ecfa-9b4c-4670-a0a2-bf13259769b4)

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/a36f10f8-03cf-44dc-93a1-a3201ad8f3af)

After this, I saved it separately as a way to track my efforts and skills:

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/437ed4c8-5095-41d7-9bce-a6eeda054442)

### Anti-Reversing Tricks #1

For example, if an application is being debugged, then the *BeingDebugged* member of the PEB structure will be equal to 1, if not, it will be 0.

Most Anti-RE tricks are only effective against Ring3 (Userland) debuggers, unless stated otherwise, or they are related to code execution time-elapsed calculation.

### 1) Direct Debugger Detection

**A).** Check -> PEB.BeingDebugged

The figure below demonstrates the layout of the PEB structure:

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/7dc7b66c-21ae-4d54-a0e2-132c6f4cde68)

The check is commonly used with WinAPIs, in order to "directly" detect if the application is being debugged. For example, a call to the ```IsDebuggerPresent``` API which checks the PEB.BeingDebugged member would detect this.

However, someone can instead implement that type of call in his own code instead of calling it, which makes it more difficult to spot. This is actaully the code executed by Windows when you call that API:

```
mox eax, dword ptr fs:[18h] <-- Get address of TEB structure
mov eax, dword pty ds:[eax+30h] <-- Get address of PEB structure
movzx eax, byte ptr ds:[eax+2] <-- Get value of PEB.BeingDebuggec
test eax, eax <-- if not zero, a debugger has been detected
jne_debugger_detected()
```

**B).** Check -> PEB.NtGlobalFlag

This has the same concept as the previous one, but this time we check another member of the PEB structure. THis member is not documented in the figure above, but we know that it is localed at ```PEB_Start + 68h```

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/b092101d-6c18-46dc-867a-c9a30ea0a90b)

**C).** CheckRemoteDebuggerPresent API

This Windows API can be used to detect if the calling process is being debugged through a Ring3 debugger, but also if another process is being debugged.

This API is actually a wrapper around the native API ```ZwQueryInformationProcess```


