0x2477# Reverse Engineering Notes

**This is just a page of notes and important things to me to remember while learning Reverse Engineering**

### Threads, Functions and Stacks

- **Each thread executing inside a process has its own stack. // 5 Threads = 5 Stacks**

- **When a function is called, it places its parameters on the stack, PUSH places data on top of the stack and POP removes that value from the top of the stack. LIFO (Last In - First Out).**

- **When an item is pushed onto the stack, the ESP register, which always points to the Top of the Stack, is decremented in order to point to the new item placed on the Top. Works the same the other way around, POPing from the stack will increment in order to point to the item below. EBP just points to the bottom becauSE IT IS A BASE POINTER.**

- **CALL is obviously responsible for executing functions, it loads the entry point of the function into the EIP register in order to run it. RET for exiting functions**

- **The program in execution needs to "remember" the return address each time the execution flow enters a function and that function needs to have its own memory area where it can store return addresses, local variables, etc. This is done by splitting the memory assigned for the stack into stack frames, each frame holds the information just mentioned for each function.**

### Heaps, Handles, and Exceptions.

- **Heaps are memory areas dynamically allocated at runtime, used to store data that doesn't have a fixed size or data that can't fit inside the stack.**

- **Handles can be considered references to various resources, and they are used by the OS in order to control the resources access (read, write, etc.)**

- **Exceptions are a specific type of event that occurs during the execution of an applications. They are usually associated with specific exception handlers, which are code blocks dedicated to handle that type of event correctly. Exceptions can also be caused by programming errors, so it is important to have an exception handler that will prevent the application from crashing unexpectedly. You also have Hardware and Software exceptions**

- **Hardware exceptions are usually caused by the execution of a bad sequence of instructions such as division by zero or an attempt to access an invalid memory location. On the other hand Software exceptions are generated by the application or the OS itself, and can be used in order to flag certain conditions with user defined exception codes.**

- **Windows implements its own mechanism to handle exceptions which is called Structured Exception Handling, or SEH for short**

- **Tricks like redirecting the execution flow to inside the handler and then back to the normal execution flow can be commonly used as an anti-reversing trick.**

### Basic Windows Ring3 Internal Structures.

- **```THREAD_ENVIRONMENT_BLOCK (TEB)```. This structure stores information such as the addresses of the top and bottom of the current thread's stack, the thread identifier, the identifier of the process the thread belongs to, the code of the last error that occurred during the thread execution, the address of the ```Thread Local Storage (TLS)```, and the address of the ```PROCESS_ENVIRONMENT_BLOCK (PEB)```**

- **```PROCESS_ENVIRONMENT_BLOCK (PEB)```. The PEB structure is also very important to understand. Some of the information stored in the PEB is: the image base of the process, the address of the loader data structure (```PEB_LDR_DATA``` - which contains pointers to lists regarding the modules loaded by the process). The ```NtGlobalFlag``` value, the major and minor versions of the Windows OS, the number of processors available, the ```BeingDebugged``` flag, and much more**

- **Some of the information stored inside PEB can be used for debugger detection, such as the ```NtGlobalFlag``` or ```BeingDebugged```.**

- **Another important structure is the ```CONTEXT``` structure, the system uses this structure to keep track of all necessary CPU state information afor a specific thread under execution during internal operations. For example, it stored the values of the registers which would be necessary to continue in the execution of the thread from the correct virtual address in case an event (like an exception) occurs.**

### Windows APIs

- **Windows APIs are Ring3 operating system functions. Their use is well documented, the parameters they receive and their purpose clear so that they can be used by the programmers in order to take advantage of the various functionalities of the operating system.**

- **Basically communication tunnel between running application and kernel**

### Types of Reversing Tools

- **Hex Editor like HxD**

- **Decompiler like DnSpy for .NET, Ghidra for native**

- **Disassembler like IDA Pro or Ghidra again**

- **Debugger like x64dbg or gdb-gef**

- **System monitoring tools like Process Hacker or Procmon**

- **Windows API monitoring tools**

### VA/RVA/Offset

- **Applications do not directly access physical memory, only virtual memory. Memory addresses referenced by an application are virtual addresses (VAs).**

- **A relative virtual address (RVA) is the difference between two VAs and refers to the highest one.**

### How to calculate offsets:
```
VA_1 = 0x00400000
VA_2 = 0x00401000
RVA of VA_2 = VA_2 - VA_1 = 0x00001000
```

- **On the other hand, offsets are usually refered to as either physical memory, a physical file on the disk, or in other general cases where we treat data as raw data, without worrying about any differences in the internal alignment of this data on memory against the one on the disk.**

- **The offset is the difference between the locations of 2 bytes, for example inside a file, usually starting from the beginning of the file. You can find this in tools like Ghidra which show the offset of certain functions and instructions.**

- **If we want to bypass a anti-reversing function or trick, we can use information like offsets of the bytes you want to modify on the disk and patching code in memory as a testing solution.**

- **Opcodes are important btw, for example ```JNZ```'s opcode would be 0x75.**

### Top Tips

- **Top tip btw, when clicking on the beginning of a function (```PUSH EBP```), you can view the functions that call this function under the CPU box:**

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/f37f14e8-c934-4cdb-91f4-6c21977a7b28)

- **Another top tip, if you're stuck in a loop, set a breakpoint just underneath it and continue running with F9 instead of spamming F8 to step over**

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/58f5d686-b1cf-4bd4-9c3e-18b1c4964b49)

- **This fucking C means CPU, click it if you get lost in execution or mem addresses on the left change to like 775B29FA**

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/4f9ef5fb-15a1-4554-8b1f-3491c93a0b08)

- **You can right click and click "New origin here" and the process will start at that instruction**



### Patching Lab #1

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/ca14c83d-ffb7-46a9-a106-83261034816b)

Here we have a regular program that is looking for a valid input, we can see at address ```0x402E76``` there is a ```JNZ``` (jump if not zero) instruction where a decision is taken regarding an output.

Above that we can see ```TEST EAX,EAX``` which checks the value of ```EAX``` to see if it is zero or not, if it is NOT then the conditional jump that follows will redirect the execution to the "invalid" message. Otherwise the execution will continue with the good message.

To bypass this, we can change the ```JNZ``` instruction to ```JZ``` using the "Assemble" command 

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/cf696601-2de8-4476-800d-e2dd790829b7)

After we edit this and run the program, we can input any key and it becomes valid

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/d2f7cbf3-f8b7-4950-a037-586dea0c7fa9)

We can also do the same thing by changing the address of the jump condition to jump to the "valid" memory address ```(0x402E78)``` instead of the invalid one ```(0x402E97```

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/1dda65f7-109e-409c-9803-1f961544817b)

### Finding Byte Offset & Cracking the Program

I want to patch the byte located at VA ```0x00402E77```, so that the program is now permanently "cracked" and will always give a "valid" answer no matter what key is inputted.

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/dfb796cf-5260-490f-a400-32003a38b912)

Use ALT+M to get to the memory map and find the first section which is at ```0x00401000```

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/d050869f-9ba3-4d80-8e18-d2ac9221dbde)

Right click the PE Header ```(0x00400000)``` and click Dump in CPU

The bottom part of the interface will now be filled with human-readable information

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/31e9ed7d-7fad-4f60-bce0-40df002af553)

Scroll down a bit more and you'll find the first section of the PE Header, the .text section.

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/cbc98583-68e4-4d66-98e1-cbe562e340aa)

The comments squared in red are the ones we will need to find the byte offset

- **VirtualSize:** The size of the section in memory.
- **VirtualAddress:** The RVA of the section in memory, not the VA.
- **SizeOfRawData:** Size of the section in the file.
- **PointerToRawData:** Starting offset of the section in the file.

The below is the formula to calculate the information

```Byte_Offset = Byte_VA - (Image_Base + Section_RVA) + PointerToRawData```

So it would be:

```0x00402E77 - (0x400000 + 0x1000) + 0x600 = 0x2477```

Putting the binary in **HxD** and scrolling down to ```0x2477``` brings us to the same hex values we saw in Ollydbg!

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/73e3f828-7b69-4352-ad94-3a64fa81c763)

And at the bottom left we can see the offset is ```0x2477```

Changing the Hex values to ```75 00``` and saving the file means we have fully patched the binary!

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/60598fe0-b265-4877-8978-c0917f3db0d7)

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/76cbd9ac-0372-4a02-8f6c-ea8dd06db4cd)

And we win!

### Exploring the Stack with Lab #2

Because strings this time are XOR encrypted and we can't just search for string references, we must use the stack while the program is running to see data being passed through it when it has been decrypted.

Using F12 or the Pause icon at the top toolbar of Ollydbg, means we can pause execution of the program and analyse the stack at runtime. After triggering a "This code is invalid!!!" I searched through the stack for this string, once i found it, i ensured this was the correct string since there were many different "This code is invalid!!!" strings on the stack, i confirmed this was my target by seeing the ```CALL``` that is made to the ```MessageBoxW``` WinAPI function.

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/50bcf678-d9d9-4ef7-afd2-f828a4464f38)

Right click on the function in the stack you want to go to in CPU, and click "Follow in Disassembler". I can also use CTRL+G to go straight to the memory address location of the function in CPU.

- **NOTE: Some Windows API names have an appended "A" or "W" in the end in order to indicate their ANSI or Unicode name respectively. For example, in case ```MessageBoxA``` call is used when we need to use ASCII character strings, otherwise, we use ```MessageBoxW``` for Unicode character strings.**

Scrolling up a bit further we can see some JMP conditional calls and more MessageBox's. This is probably where most of the decision making is happening:

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/90138792-9778-4afe-8262-6a1fa09cd125)

I can set a breakpoint just before the comparison is made to check if the right string has been inputted:

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/eb18231c-d90a-44b9-acb2-52ba39524d32)

After running the program with F9 we should hit the breakpoint and have some information in the stack:

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/3c9be26f-a5ca-4894-ab2d-5f5de353483d)

As you can see, since the code to decrypt the string has been ran, we can see the correct password for the program in the stack clearly!

```0019F4EC   0063B26C  UNICODE "Fr0m-sma11-b3g1nn1ng5-c0m3-grea7-th1ng5"```

Using this code we can check and see that we get the win

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/d14aa4f1-f2d7-4da1-a2fb-e4d270452da1)

I also used HxD to permanently patch this program, I used the Byte Offset calculation formula to get the location of the hex values that needed to be edited

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/f500ecfa-9b4c-4670-a0a2-bf13259769b4)

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/a36f10f8-03cf-44dc-93a1-a3201ad8f3af)

After this, I saved it separately as a way to track my efforts and skills:

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/437ed4c8-5095-41d7-9bce-a6eeda054442)

### Anti-Reversing Tricks #1

For example, if an application is being debugged, then the *BeingDebugged* member of the PEB structure will be equal to 1, if not, it will be 0.

Most Anti-RE tricks are only effective against Ring3 (Userland) debuggers, unless stated otherwise, or they are related to code execution time-elapsed calculation.

### 1) Direct Debugger Detection

**A).** Check -> PEB.BeingDebugged

The figure below demonstrates the layout of the PEB structure:

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/7dc7b66c-21ae-4d54-a0e2-132c6f4cde68)

The check is commonly used with WinAPIs, in order to "directly" detect if the application is being debugged. For example, a call to the ```IsDebuggerPresent``` API which checks the PEB.BeingDebugged member would detect this.

However, someone can instead implement that type of call in his own code instead of calling it, which makes it more difficult to spot. This is actaully the code executed by Windows when you call that API:

```
mox eax, dword ptr fs:[18h]      <-- Get address of TEB structure
mov eax, dword pty ds:[eax+30h]  <-- Get address of PEB structure
movzx eax, byte ptr ds:[eax+2]   <-- Get value of PEB.BeingDebuggec
test eax, eax                    <-- if not zero, a debugger has been detected
jne_debugger_detected()
```

**B).** Check -> PEB.NtGlobalFlag

This has the same concept as the previous one, but this time we check another member of the PEB structure. THis member is not documented in the figure above, but we know that it is localed at ```PEB_Start + 68h```

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/b092101d-6c18-46dc-867a-c9a30ea0a90b)

**C).** CheckRemoteDebuggerPresent API

This Windows API can be used to detect if the calling process is being debugged through a Ring3 debugger, but also if another process is being debugged.

This API is actually a wrapper around the native API ```ZwQueryInformationProcess```

The following lines of code demonstrate how a call to CheckRemoteDebuggerPresent API is normally performed, which then will also call the ```ZwQueryInformationProcess``` native API

```
push pbDebuggerPresent_address        <- push the address of a 32-bit variable
push Process_handle                   <- push the handle to a process (-1 for the calling process)
call CheckRemoteDebuggerPresent       <- call the API
mov eax, [pbDebuggerPresent_address]  <- check the returned result in the variable
test eax,eax
jne_debuggerfound                     <- if not zero, debugger was found
```

### 2) Indirect Debugger Detection

**A).** OutputDebugString API

This is used to send a string to the debugger itself

If the process is not being debugged the return value in ```EAX``` will be 1 in Windows XP and 0 in Windows Vista and above, because of the changes made to Windows Internals.

**3 ways to detect a debugger:**

- Check the returned value in EAX, depending on the Windows version as described above
- GetLastError in Windows XP. If no Ring3 debugger is present, then calling this API after the OutputDebugString will reveal an error code. If EAX == 0 then a debugger has been detected.
- Through SEH -> Works in all windows versions from XP and above, not tested in Windows 8.

**B).** OpenProcess API

Some debuggers enable the ```SeDebugPrivilege``` in their access token. The child process inherits the same privilege level as the parent process, and in this case, we refer to the debugee (the process that is being debugged).

Normally, unless specified by the author, an application will not have that privilege enabled, which means that an attempt to obtain a valid handle by using the ```OpenProcess``` API to a system process such as ```services.exe``` will fail.

On the other hand, if it succeeds, then we know that some other process escalated its privileges and we can assume that it was a debugger.

### 3) Windows Debugger Detection

The most commonly used API for obtaining a handle to the top-level window of a running application, through either its title or its class name, is the ```FindWindow``` API.

Example:

```
push 0              <- push NULL as title, we want to detect via class name
push "OLLYDBG"      <- push class name, basically pushing the string address
call FindWindow
test eax,eax
jnz_Olly_Detected   <- if eax!=0 Olly is running.
```

Sometimes though, the ```EnumWindows``` API is used, in order to enumerate all top-level windows on the screen and compare each one against a list of well-known application window names beloning to debuggers and or reversing tools.

### Anti-Reversing Tricks #2

### 1) Process Debugger Detection

This trick is used to verify that no known debugger, disassembler or reversing tool is running at the same time with our application, by retrieving a list of all running processes and evaluating their names. Usually the following Windows APIs are involved:

**CreateToolhelp32Snapshot**

Obtains a snapshot of all running processes, by using the **TH32CS_SNAPPROCESS** flag.

**Process32First**

Obtains information about the first process in the snapshot by filling the ```PROCESSENTRY32``` structure.

### 2) Parent Process Detection

A process can detect if it's being debugged by checking the name of its parent process. Usually the check is done and expecting "explorer.exe" which is commonly the parent process of a process started by the user.

The same technique is used as in the previous case, but this time we target the parent process of the process we are interested in.

The usual method involves obtaining the PID (Process IDentifier) of our process, enumerating through the processes snapshot list, locating our process and retrieving the PPID (Parent Process Identifier), and finally going once more through the processes snapshot list to see which process the PID belongs to.

A piece of malware could, for example, only accept "explorer.exe" as a legitimate parent process and act differently if it detects a different parent process.

### 3) Module Debugger Detection

This has the same goal as above (identifying debuggers), but in this case it does so by retrieving a list of all running processes and then a list of all the loaded modules of every process, such as DLLs, which are commonly used as plugins to add extra functionality to many reversing tools.

Usually the following WIndows APIs are involved:

Once again.. 

- **CreateToolhelp32Snapshot**

Obtains a snapshot of all running processes, by using the **TH32CS_SNAPPROCESS** flag.

- **Module32First**

Obtains information about the first module in the snapshot by filling in the **MODULEENTRY32** structure.

- **Module32Next**

This is used to go through the loaded modules as listed after the snapshot is taken.

### 4) Code Execution Time Detection

This is an efficient and easily implemented anti-reversing technique.

It's purpose is to evaluate the time elapsed for the execution of the instructions in a specific block of code.

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/dfcd04b4-7b10-458d-8650-50e1c08e5834)

Other Windows APIs can be used to get time related information and to achieve the same goals. Some examples are the ```timeGetTime``` and ```QueryPerformaceCounter``` APIs

### Anti-Reversing Tricks #3

### Software vs Hardware Breakpoints

A software breakpoint is placed by substituting the byte originally located at that memory address by a software interrupt - specifically the ```INT 3h``` interrupt of which the opcode is the **0xCC**

When the execution hits a ```INT 3h``` instruction, a software breakpoint exception is raised (```80000003h```) and if the process is being debugged, the debugger will force the execution to stop there.

Software breakpoints can only be used for code under execution and not memory access monitoring.

Hardware breakpoints use the debug registers ```DR0-DR3```. They can be used for different types of memory access monitoring and not to just break the execution on a specific instruction. You can set a **Hardware Breakpoint On Access** on a specific memory area which will be triggered when the virtual address space inside the process is accessed for read/write.

Hardware breakpoints dont do any code modifications in memory, this makes them very suitable to use in cases where self-modifying code is present. (Or other tricks that detect software breakpoints by calculating checksums of code blocks.)

***Software Breakpoint Detection***

```
push 'kernel32.dll'
call LoadLibrary            -> get imagebase of kernel32.dll
push 'VirtualProtect'
push eax
GetProcAddress              -> get address of 'VirtualProtect' API inside exported by kernel32.dll
cmp byte ptr ds:[eax], 0xCC -> check if there is a breakpoint set there.
```

***Hardware Breakpoint Detection***

The most common way involves the use of 2 Windows APIs:

**1).** OpenThread -> Get a handle to the desired thread.

**2).** GetThreadContext -> Read the current thread context and locate the values of the Debug Registers used to store **HW BPs, DR0-DR3**

**NOTE:** DR0-DR3 will be zero if no HW BPs are set.

### Ring0 Debuggers & System Monitoring Tools Detection

The most common use involves the usage of the CreateFile Windows API

Such types of tools use drivers with which to communicate using their own named devices:

**\\.\NTICE**  -> Softice (Windows NT)

**\\.\FILEM**  -> FileMon (Windows NT)

**\\.\REGSYS** -> RegMon (Windows NT)

So if we manage to obtain a valid handle to a specifc device like these above, then we can actually reveal the presence of the driver belonging to that tool.

### Structured Exception Handling (SEH)

This is debugger detection through exception generation.

This is mainly used for debugger detection but can be used for redirecting the execution flow under certain circumstances; it is a nice logic obfuscation tool.

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/9f30981f-f42b-42b2-bac4-3dcbb5fd41de)

So, what basically happens in this example is that we set our own exception handler and then we attempt to execute an ```INT 3h``` instruction which is the equivalant of a software breakpoint.

Depending on the debugger's settings, genrally a debugger will think that this is a software breakpoint set by the user so it will handle the generated exception itself and set the ```EIP``` to point to the next instruction ```mox eax,1```

The point is, if the process is **not** being debugged, since an exception is raised, the execution should reach the exception handler from where we can set the EIP accordingly.

***Basically, 1 if debugger detected, 0 if not detected.***

**NOTE:** Instead of INT 3h, a call to **DebugBreak** Windows API can be used which executes an INT 3h instruction.

### Unhandled Exception Filter

This is another powerful anti-reversing technique that uses a specific exception handler (normally used when there are no appropriate handlers to handle an exception)

In this case, if a process is being debugged, after the execution of the UnhandledExceptionFilter API, the process will exit instead of continuing execution which, in the context of anti-reversing properties, is very useful.

When the UnhandledExceptionFilter API is called it will itself make a call (through a subroutine) to the ZwQueryInformationProcess API asking for ProcessDebugPort information which will return **0xFFFFFFFF** if the process is being debugged by a Ring3 debugger, and **0x0** if it is not.

Basically, according to the MSDN documentation, if it returns a non zero value, the process is being debugged by a Ring3 Debugger.

### VM Detection

The use of virtualization environments for application testing and malware analysis is basic math at this point.

Some malware authors do not want their malware being analysed in a VM with no juicy info to steal, so they have functions which detect if the malware process is running inside of a Virtual Machine, if it is, it terminates.

There are many ways to achieve this, but some of them are well-known and widely used.

***VMware Detection:***

```
mov eax, 'VMXh'    <- magic number
mov ebx, 0
mov ecx, 0Ah       <- set function number / 0Ah = get VMware version
mov edx, 5658h     <- port number used to communicate with VMware
in eax, dx         <- read a dword from that port
cmp eax, ebx       <- if VMware is present EAX == EBX
je__VMware_detected
```

This piece of code uses a logical port that is used for communication between the VM and VMware itself in order to get information about the VMware version used.

The concept behind this trick is that in the ```in eax, dx``` instruction is a privileged one. We can't usually execute this instruction from usermode (Ring3)

However, the virtual CPU of VMware will allow the execution of this instruction to communicate with VMware itself.

This trick is always used along with an exception handler since if the application is not running inside VMware, a privileged instruction exception will be raised (```C0000096h```) and will cause the application to crash without the handler in place.

***VirtualPC Detection:***

```
mov ebx, 0
mov eax, 1
db 0Fh, 3Fh, 7, 0Bh // VPC Call
cmp ebx, 0
je__VPC_detected
```

The virtual CPU in VirtualPC can decode this set of bytes ```0Fh, 3Fh, 7, 0Bh``` as special call instructions which of course dont resolve to valid instructions from a native x86 CPU.

Attempting to execute this virtual instruction in a physical system will cause an illegal instruction exception (```C000001Dh```). For this reason this trick has to be used along with an associated exception handler.

***VirtualBox Detection:***

A very simple and easy way to detect VirtualBox is through the window class name of a tray icon that it places in the taskbar.

```
push 0
push 'VBoxTrayToolWndclass'
call FindWindowA
test eax, eax
jnz_VboxDetected ; if we managed to obtain a valid window handle, VBox was detected.
```

These aren't the only ways to detect VM environments, do some research.

