# Reverse Engineering Notes

**This is just a page of notes and important things to me to remember while learning Reverse Engineering**

### Threads, Functions and Stacks

- **Each thread executing inside a process has its own stack. // 5 Threads = 5 Stacks**

- **When a function is called, it places its parameters on the stack, PUSH places data on top of the stack and POP removes that value from the top of the stack. LIFO (Last In - First Out).**

- **When an item is pushed onto the stack, the ESP register, which always points to the Top of the Stack, is decremented in order to point to the new item placed on the Top. Works the same the other way around, POPing from the stack will increment in order to point to the item below. EBP just points to the bottom becauSE IT IS A BASE POINTER.**

- **CALL is obviously responsible for executing functions, it loads the entry point of the function into the EIP register in order to run it. RET for exiting functions**

- **The program in execution needs to "remember" the return address each time the execution flow enters a function and that function needs to have its own memory area where it can store return addresses, local variables, etc. This is done by splitting the memory assigned for the stack into stack frames, each frame holds the information just mentioned for each function.**

### Heaps, Handles, and Exceptions.

- **Heaps are memory areas dynamically allocated at runtime, used to store data that doesn't have a fixed size or data that can't fit inside the stack.**

- **Handles can be considered references to various resources, and they are used by the OS in order to control the resources access (read, write, etc.)**

- **Exceptions are a specific type of event that occurs during the execution of an applications. They are usually associated with specific exception handlers, which are code blocks dedicated to handle that type of event correctly. Exceptions can also be caused by programming errors, so it is important to have an exception handler that will prevent the application from crashing unexpectedly. You also have Hardware and Software exceptions**

- **Hardware exceptions are usually caused by the execution of a bad sequence of instructions such as division by zero or an attempt to access an invalid memory location. On the other hand Software exceptions are generated by the application or the OS itself, and can be used in order to flag certain conditions with user defined exception codes.**

- **Windows implements its own mechanism to handle exceptions which is called Structured Exception Handling, or SEH for short**

- **Tricks like redirecting the execution flow to inside the handler and then back to the normal execution flow can be commonly used as an anti-reversing trick.**

### Basic Windows Ring3 Internal Structures.

- **```THREAD_ENVIRONMENT_BLOCK (TEB)```. This structure stores information such as the addresses of the top and bottom of the current thread's stack, the thread identifier, the identifier of the process the thread belongs to, the code of the last error that occurred during the thread execution, the address of the ```Thread Local Storage (TLS)```, and the address of the ```PROCESS_ENVIRONMENT_BLOCK (PEB)```**

- **```PROCESS_ENVIRONMENT_BLOCK (PEB)```. The PEB structure is also very important to understand. Some of the information stored in the PEB is: the image base of the process, the address of the loader data structure (```PEB_LDR_DATA``` - which contains pointers to lists regarding the modules loaded by the process). The ```NtGlobalFlag``` value, the major and minor versions of the Windows OS, the number of processors available, the ```BeingDebugged``` flag, and much more**

- **Some of the information stored inside PEB can be used for debugger detection, such as the ```NtGlobalFlag``` or ```BeingDebugged```.**

- **Another important structure is the ```CONTEXT``` structure, the system uses this structure to keep track of all necessary CPU state information afor a specific thread under execution during internal operations. For example, it stored the values of the registers which would be necessary to continue in the execution of the thread from the correct virtual address in case an event (like an exception) occurs.**

### Windows APIs

- **Windows APIs are Ring3 operating system functions. Their use is well documented, the parameters they receive and their purpose clear so that they can be used by the programmers in order to take advantage of the various functionalities of the operating system.**

- **Basically communication tunnel between running application and kernel**

### Types of Reversing Tools

- **Hex Editor like HxD**

- **Decompiler like DnSpy for .NET, Ghidra for native**

- **Disassembler like IDA Pro or Ghidra again**

- **Debugger like x64dbg or gdb-gef**

- **System monitoring tools like Process Hacker or Procmon**

- **Windows API monitoring tools**

### VA/RVA/Offset

- **Applications do not directly access physical memory, only virtual memory. Memory addresses referenced by an application are virtual addresses (VAs).**

- **A relative virtual address (RVA) is the difference between two VAs and refers to the highest one.**

### How to calculate offsets:
```
VA_1 = 0x00400000
VA_2 = 0x00401000
RVA of VA_2 = VA_2 - VA_1 = 0x00001000
```

- **On the other hand, offsets are usually refered to as either physical memory, a physical file on the disk, or in other general cases where we treat data as raw data, without worrying about any differences in the internal alignment of this data on memory against the one on the disk.**

- **The offset is the difference between the locations of 2 bytes, for example inside a file, usually starting from the beginning of the file. You can find this in tools like Ghidra which show the offset of certain functions and instructions.**

- **If we want to bypass a anti-reversing function or trick, we can use information like offsets of the bytes you want to modify on the disk and patching code in memory as a testing solution.**

- **Opcodes are important btw, for example ```JNZ```'s opcode would be 0x75.**

### Patching Lab #1

![image](https://github.com/0xwyvn/0xwyvn.github.io/assets/114181159/ca14c83d-ffb7-46a9-a106-83261034816b)

Here we have a regular program that is looking for a valid input, we can see at address ```0x402E76``` there is a ```JNZ``` (jump if not zero) instruction where a decision is taken regarding an output.

Above that we can see ```TEST EAX,EAX``` which checks the value of ```EAX``` to see if it is zero or not, if it is NOT then the conditional jump that follows will redirect the execution to the "invalid" message. Otherwise the execution will continue with the good message.

